<!DOCTYPE html>
<html>
  <head>
    <meta name='viewport' content='width=device-width, initial-scale=1.0' />
    <meta http-equiv='Content-Type' content='text/html; charset=utf-8' />
    <title>True RandomJavaScript entropy</title>
    <link rel='shortcut icon' href='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAAIGNIUk0AAHomAACAhAAA+gAAAIDoAAB1MAAA6mAAADqYAAAXcJy6UTwAAAC0SURBVFjDY3xvF/afAQ+oX30cp9wpgTp8Whn0LFfilW85Z4hX/tnNBKziTAxDEIw6etTRo44edfSoo0cdPeroUUePOpoAYNnsEoFXwQm9nTjlqiLe4NXLxqmOV176VSVe+WtTfEeTx6ijRx096uhRR486etTRo44edfTIaZpucYjEqyBWTBinnI9GGF69L5Nq8co3+N3FK++WyD+aPEYdPeroUUePOnrU0aOOHnX0qKNHjKMByz0ZyC/b2mYAAAAASUVORK5CYII=' />
    <script>
        let intervalId;

        function peres(bits, extracted) {
          const u = [];
          const v = [];
          const l = bits.length - (bits.length & 1);

          if (l === 0) {
            return;
          }

          for (let i = 0; i < l; i += 2) {
            u.push(bits[i] ^ bits[i + 1]);
            if (bits[i] != bits[i + 1]) extracted.push(bits[i]);
            else v.push(bits[i]);
          }

          peres(u, extracted);
          peres(v, extracted);

          return extracted;
        }

        function getNow() {
          return performance.now(); // Much faster than Date.now(). Like, by a lot.
        }

        function flipCoin() {
          let coin = 0;
          const later = getNow() + 1;

          while (getNow() <= later) {
            coin ^= 1;
          }

          return coin;
        }

        function fairBits() {
          let bits = [];
          const block = 50; // too high, the animation is jerky. too low, the extraction is less efficient.

          for (let i = 0; i < block; i++) {
            bits.push(flipCoin());
          }

          return peres(bits, []);
        }

        function genBytes() {
          const bytes = [];
          const bits = fairBits();
          const l = bits.length - (bits.length & 7); // might lose some generated bits here

          for (let i = 0; i < l; i += 8) {
            bytes.push(parseInt(bits.slice(i, i + 8).join(''), 2));
          }

          return bytes;
        }

        function toBinary() {
          const bytes = genBytes();
          return bytes.map(b => b.toString(2).padStart(8, '0')).join('');
        }

        function toHex() {
          const bytes = genBytes();
          return bytes.map(b => b.toString(16).padStart(2, '0')).join('');
        }

        function toColors() {
          const rgb = [];
          const bytes = genBytes();
          const l = bytes.length - (bytes.length % 3); // might lose some generated bytes here

          for (let i = 0; i < l; i += 3) {
            rgb.push(`rgb(${bytes[i]}, ${bytes[i + 1]}, ${bytes[i + 2]})`)
          }

          return rgb;
        }

        function streamHex() {
          document.getElementById('trueRandom').insertAdjacentHTML('afterbegin', toHex());
        }

        function streamBinary() {
          document.getElementById('trueRandom').insertAdjacentHTML('afterbegin', toBinary());
        }

        function streamColors() {
          let coloredSpaces = "";
          const colors = toColors();

          for (let i = 0; i < colors.length; i++) {
            coloredSpaces += `<span style='background-color: ${colors[i]}'>&nbsp;</span>`
          }

          document.getElementById('trueRandom').insertAdjacentHTML('afterbegin', coloredSpaces);
        }

        function startStream() {
          let choice;
          const option = document.getElementById('streamChoice');
          const selected = option.options[option.selectedIndex].text;

          if (selected === 'Binary') {
            choice = streamBinary;
          } else if (selected === 'Colors') {
            choice = streamColors;
          } else if (selected === 'Hexadecimal') {
            choice = streamHex;
          }

          stopStream();
          intervalId = setInterval(choice);
        }

        function stopStream() {
          clearInterval(intervalId);
        }

        function clearStream() {
          document.getElementById('trueRandom').innerHTML = '';
        }
    </script>
    <style>
        #container {
            margin: 0 auto;
            width: 800px;
        }
        #trueRandom {
            font-family: monospace;
            margin-top: 5px;
            white-space: wrap;
            overflow-wrap: break-word;
        }
    </style>
  </head>
  <body>
    <div id="container">
        <h1>JavaScript TRNG</h1>
        <p>This is a true random number generator in pure JavaScript. No, this is not a joke. It models coin flips by pitting a slow clock (the RTC) against a fast clock (the CPU). The RTC models the coin's flight in the air and the CPU models the spin of the coin. This idea was first <a href="https://www.cs.miami.edu/home/burt/learning/Math609.0/CryptoLib/cryptolib_1.1/cryptolib/src/unix_truerand.c">investigated by cryptographer Matt Blaze 1995</a> then <a href="https://dankaminsky.com/2012/08/15/dakarand/">later by security researcher Dan Kaminsky in 2012</a>. It was also included in <a href="https://www.schneier.com/books/applied-cryptography-source/">Applied Cryptography by Bruce Schneier</a>.</p>
        <p>A timer is set 1 millisecond into the future and a bit is flipped as fast as possible before the timer expires. Due to the operating system kernel's interrupt handling, the bit flips are dependent on the stress of the system, which is chaotic and unpredictable. Finally, the bits are debiased using <a href="http://dx.doi.org/10.1214/aos/1176348543">Peres's randomness extractor</a> to ensure uniformity, which is an iterative and more efficient improvement of <a href="https://en.wikipedia.org/wiki/Randomness_extractor#Von_Neumann_extractor">John von Neumann's randomness extractor</a>.</p>
        <p>This page is entirely self-contained and does not require any external resources. Download this page to your computer, and run it offline. It's designed to behave similarly to the live streams feature provided by the <a href="https://qrng.anu.edu.au/">Australian National University QRNG</a>. Due to the 1 millisecond timer however, it is slower than most modern RNGs.</p>
        <select id="streamChoice">
            <option>Binary</option>
            <option>Colors</option>
            <option selected>Hexadecimal</option>
        </select>
        <button onclick="startStream()">Start</button>
        <button onclick="stopStream()">Stop</button>
        <button onclick="clearStream()">Clear</button>
        <div id="trueRandom"></div textarea>
    </div>
    <script>
        startStream()
    </script>
  </body>
</html>
