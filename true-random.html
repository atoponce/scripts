<!DOCTYPE html>
<html>
  <head>
    <meta name='viewport' content='width=device-width, initial-scale=1.0' />
    <meta http-equiv='Content-Type' content='text/html; charset=utf-8' />
    <title>True RandomJavaScript entropy</title>
    <link rel='shortcut icon' href='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAAIGNIUk0AAHomAACAhAAA+gAAAIDoAAB1MAAA6mAAADqYAAAXcJy6UTwAAAC0SURBVFjDY3xvF/afAQ+oX30cp9wpgTp8Whn0LFfilW85Z4hX/tnNBKziTAxDEIw6etTRo44edfSoo0cdPeroUUePOpoAYNnsEoFXwQm9nTjlqiLe4NXLxqmOV176VSVe+WtTfEeTx6ijRx096uhRR486etTRo44edfTIaZpucYjEqyBWTBinnI9GGF69L5Nq8co3+N3FK++WyD+aPEYdPeroUUePOnrU0aOOHnX0qKNHjKMByz0ZyC/b2mYAAAAASUVORK5CYII=' />
    <script>
        let intervalId;

        // Redundancy: O(1)
        // Time complexity: O(n log n)
        // Space complexity: O(1)
        function peres(bits, extracted) {
          const u = []; // discarded bits to be iterated again
          const v = []; // discarded bits to be iterated again
          const l = bits.length - (bits.length & 1); // force an even length

          if (l === 0) {
            return;
          }

          for (let i = 0; i < l; i += 2) {
            u.push(bits[i] ^ bits[i + 1]);
            if (bits[i] != bits[i + 1]) extracted.push(bits[i]);
            else v.push(bits[i]);
          }

          peres(u, extracted); // recursively extract discarded u-bits
          peres(v, extracted); // recursively extract discarded v-bits

          return extracted;
        }

        function getNow() {
          return performance.now(); // Much faster than Date.now(). Like, by a lot.
        }

        function flipCoin() {
          let coin = 0;
          const later = getNow() + 1; // The coin's flight in the air.

          while (getNow() <= later) {
            coin ^= 1; // The coin spinning while in flight.
          }

          return coin;
        }

        function fairBits() {
          let bits = [];

          // Number of bits to generate before returning. Because we're waiting at least 1ms for each bit,
          // this is the total number of ms before returning. If this value is high, while the extraction
          // will be efficient, the animation will be jerky. If this value is low, the animation will run
          // buttery smooth, but the extraction much less efficient and the animation slower.
          // Do not set below 50, or the colors animation will struggle to execute.
          // 75 is a good compromise. It produces an even 6 bytes most of the time, perfect for colors.
          const block = 75;

          for (let i = 0; i < block; i++) {
            bits.push(flipCoin());
          }

          return peres(bits, []);
        }

        function genBytes() {
          const bytes = [];
          const bits = fairBits();
          const l = bits.length - (bits.length & 7); // might lose some generated bits here

          for (let i = 0; i < l; i += 8) {
            bytes.push(parseInt(bits.slice(i, i + 8).join(''), 2));
          }

          return bytes;
        }

        function toBinary() {
          const bytes = genBytes();
          return bytes.map(b => b.toString(2).padStart(8, '0')).join('');
        }

        function toHex() {
          const bytes = genBytes();
          return bytes.map(b => b.toString(16).padStart(2, '0')).join('');
        }

        function toColors() {
          const rgb = [];
          const bytes = genBytes();
          const l = bytes.length - (bytes.length % 3); // might lose some generated bytes here

          for (let i = 0; i < l; i += 3) {
            rgb.push(`rgb(${bytes[i]}, ${bytes[i + 1]}, ${bytes[i + 2]})`)
          }

          return rgb;
        }

        function streamHex() {
          document.getElementById('trueRandom').insertAdjacentHTML('afterbegin', toHex());
        }

        function streamBinary() {
          document.getElementById('trueRandom').insertAdjacentHTML('afterbegin', toBinary());
        }

        function streamColors() {
          let coloredSpaces = "";
          const colors = toColors();

          for (let i = 0; i < colors.length; i++) {
            coloredSpaces += `<span style='background-color: ${colors[i]}'>&nbsp;</span>`
          }

          document.getElementById('trueRandom').insertAdjacentHTML('afterbegin', coloredSpaces);
        }

        function startStream() {
          let choice;
          const option = document.getElementById('streamChoice');
          const selected = option.options[option.selectedIndex].text;

          if (selected === 'Binary') {
            choice = streamBinary;
          } else if (selected === 'Colors') {
            choice = streamColors;
          } else if (selected === 'Hexadecimal') {
            choice = streamHex;
          }

          stopStream();
          intervalId = setInterval(choice);
        }

        function stopStream() {
          clearInterval(intervalId);
        }

        function clearStream() {
          document.getElementById('trueRandom').innerHTML = '';
        }
    </script>
    <style>
        #container {
            margin: 0 auto;
            width: 800px;
        }
        #trueRandom {
            font-family: monospace;
            margin-top: 5px;
            white-space: wrap;
            overflow-wrap: break-word;
        }
    </style>
  </head>
  <body>
    <div id="container">
        <h1>JavaScript TRNG</h1>
        <p>This is a true random number generator in pure JavaScript. No, this is not a joke. It models coin flips by pitting a slow clock (the RTC) against a fast clock (the CPU). The RTC models the coin's flight in the air and the CPU models the spin of the coin. This idea was first <a href="https://www.cs.miami.edu/home/burt/learning/Math609.0/CryptoLib/cryptolib_1.1/cryptolib/src/unix_truerand.c">investigated by cryptographer Matt Blaze 1995</a> then <a href="https://dankaminsky.com/2012/08/15/dakarand/">later by security researcher Dan Kaminsky in 2012</a>. It was also included in <a href="https://www.schneier.com/books/applied-cryptography-source/">Applied Cryptography by Bruce Schneier</a>.</p>
        <p>A timer is set 1 millisecond into the future and a bit is flipped as fast as possible before the timer expires. Due to the operating system kernel's interrupt handling, the bit flips are dependent on the stress of the system, which is chaotic and unpredictable. Finally, the bits are debiased using <a href="http://dx.doi.org/10.1214/aos/1176348543">Peres's randomness extractor</a> to ensure uniformity, which is an iterative and more efficient improvement of <a href="https://en.wikipedia.org/wiki/Randomness_extractor#Von_Neumann_extractor">John von Neumann's randomness extractor</a>.</p>
        <p>This page is entirely self-contained and does not require any external resources. Download this page to your computer, and run it offline. It's designed to behave similarly to the live streams feature provided by the <a href="https://qrng.anu.edu.au/">Australian National University QRNG</a>. Due to the 1 millisecond timer however, it is slower than most modern RNGs.</p>
        <select id="streamChoice">
            <option>Binary</option>
            <option>Colors</option>
            <option selected>Hexadecimal</option>
        </select>
        <button onclick="startStream()">Start</button>
        <button onclick="stopStream()">Stop</button>
        <button onclick="clearStream()">Clear</button>
        <div id="trueRandom"></div textarea>
    </div>
    <script>
        startStream()
    </script>
  </body>
</html>
